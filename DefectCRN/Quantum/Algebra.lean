/-
Copyright (c) 2026 Paolo Vella. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Paolo Vella
-/
import DefectCRN.Quantum.Lindbladian
import Mathlib.Algebra.Algebra.Subalgebra.Basic
import Mathlib.LinearAlgebra.FiniteDimensional.Defs
import Mathlib.Algebra.Polynomial.AlgebraMap

/-!
# Lindblad Algebra and Commutant
-/

set_option linter.unusedVariables false
set_option linter.unusedSectionVars false

namespace DefectCRN.Quantum

open scoped Matrix BigOperators
open Matrix

variable {n : ℕ} [NeZero n]

/-- The set of generators for the Lindblad algebra -/
def lindbladGenerators (L : Lindbladian n) : Set (Matrix (Fin n) (Fin n) ℂ) :=
  {L.hamiltonian} ∪ L.jumpOps.toFinset ∪ (L.jumpOps.map dagger).toFinset

/-- The Lindblad algebra: subalgebra generated by H and jump operators -/
noncomputable def lindbladAlgebra (L : Lindbladian n) :
    Subalgebra ℂ (Matrix (Fin n) (Fin n) ℂ) :=
  Algebra.adjoin ℂ (lindbladGenerators L)

/-- An operator X is in the commutant if it commutes with all generators -/
def IsInCommutant (L : Lindbladian n) (X : Matrix (Fin n) (Fin n) ℂ) : Prop :=
  ⟦X, L.hamiltonian⟧ = 0 ∧
  (∀ Lk ∈ L.jumpOps, ⟦X, Lk⟧ = 0) ∧
  (∀ Lk ∈ L.jumpOps, ⟦X, Lk†⟧ = 0)

/-- The commutant as a set -/
def commutantSet (L : Lindbladian n) : Set (Matrix (Fin n) (Fin n) ℂ) :=
  {X | IsInCommutant L X}

/-- The commutant as a submodule -/
noncomputable def commutantSubmodule (L : Lindbladian n) : Submodule ℂ (Matrix (Fin n) (Fin n) ℂ) where
  carrier := commutantSet L
  zero_mem' := by
    simp only [commutantSet, Set.mem_setOf_eq, IsInCommutant]
    constructor
    · simp [commutator]
    constructor
    · intro Lk _; simp [commutator]
    · intro Lk _; simp [commutator]
  add_mem' := by
    intro X Y hX hY
    simp only [commutantSet, Set.mem_setOf_eq, IsInCommutant] at hX hY ⊢
    constructor
    · rw [commutator_add_left, hX.1, hY.1, add_zero]
    constructor
    · intro Lk hLk
      rw [commutator_add_left, hX.2.1 Lk hLk, hY.2.1 Lk hLk, add_zero]
    · intro Lk hLk
      rw [commutator_add_left, hX.2.2 Lk hLk, hY.2.2 Lk hLk, add_zero]
  smul_mem' := by
    intro c X hX
    simp only [commutantSet, Set.mem_setOf_eq, IsInCommutant] at hX ⊢
    constructor
    · rw [commutator_smul_left, hX.1, smul_zero]
    constructor
    · intro Lk hLk
      rw [commutator_smul_left, hX.2.1 Lk hLk, smul_zero]
    · intro Lk hLk
      rw [commutator_smul_left, hX.2.2 Lk hLk, smul_zero]

/-- Membership in commutantSubmodule is equivalent to IsInCommutant -/
theorem mem_commutantSubmodule_iff (L : Lindbladian n) (X : Matrix (Fin n) (Fin n) ℂ) :
    X ∈ commutantSubmodule L ↔ IsInCommutant L X := Iff.rfl

/-- The commutant is closed under dagger (adjoint) -/
theorem commutant_closed_dagger (L : Lindbladian n) (X : Matrix (Fin n) (Fin n) ℂ)
    (hX : X ∈ commutantSubmodule L) : X† ∈ commutantSubmodule L := by
  simp only [commutantSubmodule, Submodule.mem_mk, Set.mem_setOf_eq, IsInCommutant] at hX ⊢
  obtain ⟨hH, hL, hLdag⟩ := hX
  constructor
  · -- [X†, H] = 0 since H is Hermitian and [X, H] = 0
    exact commutator_dagger_hermitian X L.hamiltonian L.hamiltonian_hermitian hH
  constructor
  · -- [X†, Lk] = 0 using [X, Lk] = 0 and [X, Lk†] = 0
    intro Lk hLk
    exact commutator_dagger_from_both X Lk (hL Lk hLk) (hLdag Lk hLk)
  · -- [X†, Lk†] = 0 using the fact that (Lk†)† = Lk
    intro Lk hLk
    have h1 : ⟦X, Lk⟧ = 0 := hL Lk hLk
    -- We need [X†, Lk†] = 0. Using [X, Lk] = 0 and the identity [A, B]† = [B†, A†]
    have hdagger : ⟦X, Lk⟧† = ⟦Lk†, X†⟧ := commutator_dagger X Lk
    rw [h1] at hdagger
    simp only [dagger, conjTranspose_zero] at hdagger
    -- hdagger : 0 = ⟦Lkᴴ, Xᴴ⟧
    -- So [Lk†, X†] = 0, which means [X†, Lk†] = -[Lk†, X†] = 0
    simp only [dagger]
    rw [commutator_antisymm, ← hdagger, neg_zero]

/-- The Hermitian part of a commutant element is in the commutant -/
theorem hermitianPart_mem_commutant (L : Lindbladian n) (X : Matrix (Fin n) (Fin n) ℂ)
    (hX : X ∈ commutantSubmodule L) : hermitianPart X ∈ commutantSubmodule L := by
  unfold hermitianPart
  have hXdag := commutant_closed_dagger L X hX
  exact (commutantSubmodule L).smul_mem (1/2) ((commutantSubmodule L).add_mem hX hXdag)

/-- The skew-Hermitian part of a commutant element is in the commutant -/
theorem skewHermitianPart_mem_commutant (L : Lindbladian n) (X : Matrix (Fin n) (Fin n) ℂ)
    (hX : X ∈ commutantSubmodule L) : skewHermitianPart X ∈ commutantSubmodule L := by
  unfold skewHermitianPart
  have hXdag := commutant_closed_dagger L X hX
  exact (commutantSubmodule L).smul_mem (-Complex.I / 2) ((commutantSubmodule L).sub_mem hX hXdag)

/-- The commutant is trivial (only scalar matrices) -/
def hasTrivialCommutant (L : Lindbladian n) : Prop :=
  ∀ X ∈ commutantSet L, ∃ c : ℂ, X = c • (1 : Matrix (Fin n) (Fin n) ℂ)

/-- The scalar matrices form a 1-dimensional submodule -/
noncomputable def scalarSubmodule (n : ℕ) [NeZero n] : Submodule ℂ (Matrix (Fin n) (Fin n) ℂ) :=
  Submodule.span ℂ {(1 : Matrix (Fin n) (Fin n) ℂ)}

/-- Trivial commutant means commutant is the scalar submodule -/
theorem trivialCommutant_eq_scalar (L : Lindbladian n) (h : hasTrivialCommutant L) :
    commutantSubmodule L = scalarSubmodule n := by
  ext X
  constructor
  · intro hX
    simp only [commutantSubmodule, Submodule.mem_mk, Set.mem_setOf_eq] at hX
    obtain ⟨c, hc⟩ := h X hX
    simp only [scalarSubmodule, Submodule.mem_span_singleton]
    exact ⟨c, hc.symm⟩
  · intro hX
    simp only [scalarSubmodule, Submodule.mem_span_singleton] at hX
    obtain ⟨c, hc⟩ := hX
    simp only [commutantSubmodule, Submodule.mem_mk, Set.mem_setOf_eq, IsInCommutant]
    subst hc
    constructor
    · simp [commutator, Matrix.smul_mul, Matrix.mul_smul]
    constructor
    · intro Lk _; simp [commutator, Matrix.smul_mul, Matrix.mul_smul]
    · intro Lk _; simp [commutator, Matrix.smul_mul, Matrix.mul_smul]

/-- The commutant is closed under multiplication -/
theorem commutant_closed_mul (L : Lindbladian n) (X Y : Matrix (Fin n) (Fin n) ℂ)
    (hX : X ∈ commutantSubmodule L) (hY : Y ∈ commutantSubmodule L) :
    X * Y ∈ commutantSubmodule L := by
  simp only [commutantSubmodule, Submodule.mem_mk, Set.mem_setOf_eq, IsInCommutant] at hX hY ⊢
  obtain ⟨hXH, hXL, hXLd⟩ := hX
  obtain ⟨hYH, hYL, hYLd⟩ := hY
  constructor
  · -- [XY, H] = 0
    -- [XY, H] = X[Y,H] + [X,H]Y = X·0 + 0·Y = 0
    have h1 : ⟦X * Y, L.hamiltonian⟧ = X * ⟦Y, L.hamiltonian⟧ + ⟦X, L.hamiltonian⟧ * Y := by
      simp only [commutator]
      noncomm_ring
    rw [h1, hXH, hYH, mul_zero, zero_mul, add_zero]
  constructor
  · -- [XY, Lk] = 0 for all jump operators
    intro Lk hLk
    have h1 : ⟦X * Y, Lk⟧ = X * ⟦Y, Lk⟧ + ⟦X, Lk⟧ * Y := by
      simp only [commutator]
      noncomm_ring
    rw [h1, hXL Lk hLk, hYL Lk hLk, mul_zero, zero_mul, add_zero]
  · -- [XY, Lk†] = 0 for all jump operators
    intro Lk hLk
    have h1 : ⟦X * Y, Lk†⟧ = X * ⟦Y, Lk†⟧ + ⟦X, Lk†⟧ * Y := by
      simp only [commutator, dagger]
      noncomm_ring
    rw [h1, hXLd Lk hLk, hYLd Lk hLk, mul_zero, zero_mul, add_zero]

/-- Powers of commutant elements are in the commutant -/
theorem commutant_closed_pow (L : Lindbladian n) (X : Matrix (Fin n) (Fin n) ℂ)
    (hX : X ∈ commutantSubmodule L) (k : ℕ) :
    X ^ k ∈ commutantSubmodule L := by
  induction k with
  | zero =>
    simp only [pow_zero]
    -- 1 ∈ commutant: [1, Z] = 0 for any Z
    simp only [commutantSubmodule, Submodule.mem_mk, Set.mem_setOf_eq, IsInCommutant]
    constructor
    · simp [commutator]
    constructor
    · intro Lk _; simp [commutator]
    · intro Lk _; simp [commutator]
  | succ k ih =>
    rw [pow_succ']  -- X^(k+1) = X * X^k
    exact commutant_closed_mul L X (X ^ k) hX ih

/-- The scalar submodule has dimension 1 -/
theorem finrank_scalarSubmodule (n : ℕ) [NeZero n] :
    Module.finrank ℂ (scalarSubmodule n) = 1 := by
  simp only [scalarSubmodule]
  have h : (1 : Matrix (Fin n) (Fin n) ℂ) ≠ 0 := by
    intro hcontra
    have h00 : (1 : Matrix (Fin n) (Fin n) ℂ) 0 0 = (0 : Matrix (Fin n) (Fin n) ℂ) 0 0 := by rw [hcontra]
    simp only [Matrix.one_apply_eq, Matrix.zero_apply] at h00
    exact one_ne_zero h00
  exact finrank_span_singleton h

/-- Trivial commutant has dimension 1 -/
theorem finrank_trivialCommutant (L : Lindbladian n) (h : hasTrivialCommutant L) :
    Module.finrank ℂ (commutantSubmodule L) = 1 := by
  rw [trivialCommutant_eq_scalar L h]
  exact finrank_scalarSubmodule n

/-- Identity matrix is in the commutant -/
theorem one_mem_commutant (L : Lindbladian n) : (1 : Matrix (Fin n) (Fin n) ℂ) ∈ commutantSubmodule L := by
  simp only [commutantSubmodule, Submodule.mem_mk, Set.mem_setOf_eq, IsInCommutant]
  constructor
  · simp [commutator]
  constructor
  · intro Lk _; simp [commutator]
  · intro Lk _; simp [commutator]

/-- Polynomial evaluation of a commutant element stays in commutant.

    If H ∈ commutant(L), then for any polynomial p, p(H) ∈ commutant(L).
    This follows from commutant_closed_pow (H^k ∈ commutant) and linearity. -/
theorem commutant_closed_polynomial (L : Lindbladian n)
    (H : Matrix (Fin n) (Fin n) ℂ) (hH : H ∈ commutantSubmodule L)
    (p : Polynomial ℂ) : Polynomial.aeval H p ∈ commutantSubmodule L := by
  induction p using Polynomial.induction_on with
  | h_C c =>
    simp only [Polynomial.aeval_C, Algebra.algebraMap_eq_smul_one]
    exact (commutantSubmodule L).smul_mem c (one_mem_commutant L)
  | h_add f g hf hg =>
    rw [map_add]
    exact (commutantSubmodule L).add_mem hf hg
  | h_monomial k c _ =>
    rw [_root_.map_mul, Polynomial.aeval_C, Polynomial.aeval_X_pow]
    have hpow : H ^ (k + 1) ∈ commutantSubmodule L := commutant_closed_pow L H hH (k + 1)
    have h1 : (1 : Matrix (Fin n) (Fin n) ℂ) ∈ commutantSubmodule L := one_mem_commutant L
    have hc1 : (algebraMap ℂ (Matrix (Fin n) (Fin n) ℂ)) c ∈ commutantSubmodule L := by
      rw [Algebra.algebraMap_eq_smul_one]
      exact (commutantSubmodule L).smul_mem c h1
    exact commutant_closed_mul L _ _ hc1 hpow

/-- Scalar submodule is contained in commutant -/
theorem scalarSubmodule_le_commutant (L : Lindbladian n) :
    scalarSubmodule n ≤ commutantSubmodule L := by
  intro X hX
  simp only [scalarSubmodule, Submodule.mem_span_singleton] at hX
  obtain ⟨c, hc⟩ := hX
  simp only [commutantSubmodule, Submodule.mem_mk, Set.mem_setOf_eq, IsInCommutant]
  subst hc
  constructor
  · simp [commutator, Matrix.smul_mul, Matrix.mul_smul]
  constructor
  · intro Lk _; simp [commutator, Matrix.smul_mul, Matrix.mul_smul]
  · intro Lk _; simp [commutator, Matrix.smul_mul, Matrix.mul_smul]

/-- If commutant has dimension 1, then it's trivial -/
theorem commutant_dim_one_implies_trivial (L : Lindbladian n)
    (h : Module.finrank ℂ (commutantSubmodule L) = 1) : hasTrivialCommutant L := by
  -- The scalar submodule has dimension 1 and is contained in commutant
  -- If commutant has dimension 1, they must be equal
  have hScalarDim := finrank_scalarSubmodule n
  have hLe := scalarSubmodule_le_commutant L
  -- Two submodules with same finite dimension where one ≤ other must be equal
  have hFinrank : Module.finrank ℂ (scalarSubmodule n) = Module.finrank ℂ (commutantSubmodule L) := by
    rw [hScalarDim, h]
  have hEq : scalarSubmodule n = commutantSubmodule L :=
    Submodule.eq_of_le_of_finrank_eq hLe hFinrank
  -- Now trivialCommutant follows from equality
  intro X hX
  have hXmem : X ∈ commutantSubmodule L := hX
  rw [← hEq] at hXmem
  simp only [scalarSubmodule, Submodule.mem_span_singleton] at hXmem
  obtain ⟨c, hc⟩ := hXmem
  exact ⟨c, hc.symm⟩

/-- Dimension of the commutant equals dimension of stationary space.

    This is a fundamental result connecting the algebraic structure (commutant)
    to the dynamical structure (stationary states). The proof involves:
    1. The duality between the Lindblad algebra and its commutant
    2. Fixed point theory for completely positive maps
    3. The relationship between peripheral spectrum and stationary states

    Mathematical justification:
    - The commutant Comm(L) consists of matrices commuting with all generators
    - The stationary space ker(L) consists of fixed points of the dynamics
    - Both are related to the peripheral spectrum of the quantum channel
    - For finite dimensions, the structure theorem for quantum channels shows
      that the multiplicities match: dim(Comm) = dim(ker L)

    This is known as the Evans-Høegh-Krohn theorem for quantum dynamical semigroups.

    References:
    - Evans, D.E., Høegh-Krohn, R. "Spectral properties of positive maps on C*-algebras"
      Comm. Math. Phys. 58 (1978), 229-276
    - Wolf, M.M. "Quantum Channels & Operations: Guided Tour" (2012), Section 6
    - Frigerio, A. "Stationary states of quantum dynamical semigroups"
      Comm. Math. Phys. 63 (1978), 269-276 -/
axiom commutant_dim_eq_stationary_dim (L : Lindbladian n) :
    Module.finrank ℂ (commutantSubmodule L) = Module.finrank ℂ L.stationarySubspace

end DefectCRN.Quantum
