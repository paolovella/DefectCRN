/-
Copyright (c) 2026 Paolo Vella. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Paolo Vella
-/
import DefectCRN.Quantum.Algebra
import Mathlib.Algebra.Algebra.Subalgebra.Basic
import Mathlib.RingTheory.Artinian

/-!
# The Interaction Algebra and Basis-Invariant Classification

This file defines the **interaction algebra** A_int, a basis-invariant structural
invariant that replaces the basis-dependent support graph approach.

## Main Definitions

* `interactionAlgebra L`: The *-subalgebra generated by H and the jump operators
* `centerDimension`: dim Z(A_int), the canonical "block count"
* `centralDeficiency`: δ_cen = dim Z(A_int) - 1

## Key Properties

The interaction algebra is:
1. **Basis-invariant**: Defined intrinsically from the Lindbladian
2. **Gauge-invariant**: Independent of GKSL representation choices
3. **Computable**: Finite-dimensional closure under multiplication and *

## Relation to Existing Notions

* `structuralDeficiency` ≤ `centralDeficiency` ≤ `quantumDeficiency`
* For non-degenerate graphs, structural and central deficiency coincide
* The gap measures "accidental" vs "structural" degeneracy

## References

* Wedderburn structure theorem for finite-dimensional *-algebras
* Wolf, "Quantum Channels & Operations" (2012) for GKSL structure
-/

set_option linter.unusedVariables false
set_option linter.unusedSectionVars false

namespace DefectCRN.Quantum

open scoped Matrix BigOperators
open Matrix

variable {n : ℕ} [NeZero n]

/-! ## The Interaction Algebra -/

/-- The set of generators for the interaction algebra:
    {H} ∪ {L_k} ∪ {L_k†}

    This is the minimal generating set for the *-algebra of "noise operators". -/
def interactionGenerators (L : Lindbladian n) : Set (Matrix (Fin n) (Fin n) ℂ) :=
  {L.hamiltonian} ∪ L.jumpOps.toFinset ∪ (L.jumpOps.map dagger).toFinset

/-- The interaction algebra A_int = Alg*(H, L_1, ..., L_m).

    This is the *-subalgebra of M_n(ℂ) generated by the Hamiltonian and
    jump operators. It captures the "noise structure" in a basis-invariant way.

    Key property: The commutant of A_int equals the asymptotic fixed-point algebra
    under mild assumptions (faithful invariant state). -/
noncomputable def interactionAlgebra (L : Lindbladian n) :
    Subalgebra ℂ (Matrix (Fin n) (Fin n) ℂ) :=
  Algebra.adjoin ℂ (interactionGenerators L)

/-- The interaction algebra contains the Hamiltonian -/
theorem hamiltonian_mem_interactionAlgebra (L : Lindbladian n) :
    L.hamiltonian ∈ interactionAlgebra L := by
  unfold interactionAlgebra interactionGenerators
  apply Algebra.subset_adjoin
  left; left
  exact Set.mem_singleton_iff.mpr rfl

/-- The interaction algebra contains all jump operators -/
theorem jumpOp_mem_interactionAlgebra (L : Lindbladian n)
    (Lk : Matrix (Fin n) (Fin n) ℂ) (hLk : Lk ∈ L.jumpOps) :
    Lk ∈ interactionAlgebra L := by
  unfold interactionAlgebra interactionGenerators
  apply Algebra.subset_adjoin
  left; right
  exact List.mem_toFinset.mpr hLk

/-- The interaction algebra contains all adjoint jump operators -/
theorem jumpOp_dag_mem_interactionAlgebra (L : Lindbladian n)
    (Lk : Matrix (Fin n) (Fin n) ℂ) (hLk : Lk ∈ L.jumpOps) :
    Lk† ∈ interactionAlgebra L := by
  unfold interactionAlgebra interactionGenerators
  apply Algebra.subset_adjoin
  right
  show Lk† ∈ (L.jumpOps.map dagger).toFinset
  rw [List.mem_toFinset, List.mem_map]
  exact ⟨Lk, hLk, rfl⟩

/-- Helper: Identity matrix dagger is itself -/
private theorem dagger_one' : (1 : Matrix (Fin n) (Fin n) ℂ)† = 1 := by
  simp only [dagger]
  ext i j
  simp [Matrix.conjTranspose, Matrix.one_apply]

/-- The interaction algebra is closed under the †-operation.
    This makes it a *-subalgebra. -/
theorem interactionAlgebra_closed_dagger (L : Lindbladian n)
    (X : Matrix (Fin n) (Fin n) ℂ) (hX : X ∈ interactionAlgebra L) :
    X† ∈ interactionAlgebra L := by
  -- The adjoin is closed under † because:
  -- 1. Generators include both L_k and L_k†
  -- 2. H is Hermitian so H† = H
  -- 3. (XY)† = Y†X† and (X+Y)† = X†+Y†
  unfold interactionAlgebra at hX ⊢
  induction hX using Algebra.adjoin_induction with
  | mem a ha =>
    -- Case: a is a generator
    unfold interactionGenerators at ha
    rcases ha with (⟨ha, rfl⟩ | ha) | ha
    · -- a = H, which is Hermitian so H† = H
      have hHerm : L.hamiltonian† = L.hamiltonian := by
        simp only [dagger]; exact L.hamiltonian_hermitian.eq
      rw [hHerm]
      exact Algebra.subset_adjoin (Set.mem_union_left _ (Set.mem_union_left _ (Set.mem_singleton_iff.mpr rfl)))
    · -- a ∈ L.jumpOps, so a† is in the generators (the dagger set)
      rw [Finset.mem_coe, List.mem_toFinset] at ha
      apply Algebra.subset_adjoin
      right
      show a† ∈ (L.jumpOps.map dagger).toFinset
      rw [List.mem_toFinset, List.mem_map]
      exact ⟨a, ha, rfl⟩
    · -- a ∈ L.jumpOps.map dagger, so a = Lk† and a† = Lk ∈ L.jumpOps
      rw [Finset.mem_coe, List.mem_toFinset, List.mem_map] at ha
      obtain ⟨Lk, hLk, rfl⟩ := ha
      rw [dagger_dagger]
      apply Algebra.subset_adjoin
      left; right
      rw [Finset.mem_coe, List.mem_toFinset]
      exact hLk
  | algebraMap c =>
    -- Case: scalar (c : ℂ), need (c • 1)† = star c • 1 ∈ A_int
    simp only [Algebra.algebraMap_eq_smul_one]
    rw [dagger_smul, dagger_one']
    exact Subalgebra.smul_mem _ (Subalgebra.one_mem _) _
  | add X₁ X₂ _ _ hX₁ hX₂ =>
    -- Case: X = X₁ + X₂
    rw [dagger_add]
    exact Subalgebra.add_mem _ hX₁ hX₂
  | mul X₁ X₂ _ _ hX₁ hX₂ =>
    -- Case: X = X₁ * X₂, and (X₁ * X₂)† = X₂† * X₁†
    rw [dagger_mul]
    exact Subalgebra.mul_mem _ hX₂ hX₁

/-! ## The Commutant and Its Relation to A_int -/

/-- The commutant of the interaction algebra.

    This is a basis-invariant version of the commutantSubmodule.
    Key theorem (Evans-Høegh-Krohn): With faithful σ, this equals ker(L*). -/
def interactionCommutant (L : Lindbladian n) : Set (Matrix (Fin n) (Fin n) ℂ) :=
  {X | ∀ A ∈ interactionAlgebra L, ⟦X, A⟧ = 0}

/-- The commutant of the interaction algebra is a *-subalgebra -/
theorem interactionCommutant_is_subalgebra (L : Lindbladian n) :
    ∀ X, X ∈ interactionCommutant L → ∀ Y, Y ∈ interactionCommutant L →
    X * Y ∈ interactionCommutant L := by
  intro X hX Y hY
  simp only [interactionCommutant, Set.mem_setOf_eq] at *
  intro A hA
  -- [XY, A] = X[Y,A] + [X,A]Y = X·0 + 0·Y = 0
  calc ⟦X * Y, A⟧ = X * ⟦Y, A⟧ + ⟦X, A⟧ * Y := commutator_mul_general X Y A
    _ = X * 0 + 0 * Y := by rw [hY A hA, hX A hA]
    _ = 0 := by simp [mul_zero, zero_mul]

/-- The commutantSubmodule equals the interaction commutant on generators.
    This connects the new basis-invariant definition to the existing one. -/
theorem commutantSubmodule_eq_interactionCommutant (L : Lindbladian n) :
    (commutantSubmodule L : Set (Matrix (Fin n) (Fin n) ℂ)) ⊆ interactionCommutant L := by
  intro X hX
  simp only [commutantSubmodule, Submodule.mem_mk, Set.mem_setOf_eq,
    IsInCommutant] at hX
  simp only [interactionCommutant, Set.mem_setOf_eq]
  intro A hA
  -- Need to show [X, A] = 0 for all A in A_int
  -- Since X commutes with all generators, and A_int is generated by them,
  -- X commutes with all of A_int
  -- Use Algebra.adjoin_induction to prove by induction on A's construction
  unfold interactionAlgebra at hA
  -- Apply induction on A's construction in A_int
  induction hA using Algebra.adjoin_induction with
  | mem a ha =>
    -- Case: A is in generators
    unfold interactionGenerators at ha
    rcases ha with (⟨ha, rfl⟩ | ha) | ha
    · -- A = H
      exact hX.1
    · -- A ∈ L.jumpOps
      rw [Finset.mem_coe, List.mem_toFinset] at ha
      exact hX.2.1 a ha
    · -- A ∈ L.jumpOps†
      rw [Finset.mem_coe, List.mem_toFinset, List.mem_map] at ha
      obtain ⟨Lk, hLk, rfl⟩ := ha
      exact hX.2.2 Lk hLk
  | algebraMap c =>
    -- Case: A is a scalar (c : ℂ)
    simp only [Algebra.algebraMap_eq_smul_one, commutator, Matrix.smul_mul, Matrix.mul_smul,
      Matrix.mul_one, Matrix.one_mul, sub_self]
  | add A₁ A₂ _ _ hA₁ hA₂ =>
    -- Case: A = A₁ + A₂
    rw [commutator_add_right, hA₁, hA₂, add_zero]
  | mul A₁ A₂ _ _ hA₁ hA₂ =>
    -- Case: A = A₁ * A₂
    calc ⟦X, A₁ * A₂⟧ = A₁ * ⟦X, A₂⟧ := commutator_mul_left X A₁ A₂ hA₁
      _ = A₁ * 0 := by rw [hA₂]
      _ = 0 := mul_zero A₁

/-! ## The Center of the Interaction Algebra -/

/-- The center of the interaction algebra Z(A_int).

    This is the set of elements that commute with all of A_int.
    Its dimension gives the canonical "block count". -/
def interactionCenter (L : Lindbladian n) : Set (Matrix (Fin n) (Fin n) ℂ) :=
  {X ∈ interactionAlgebra L | ∀ A ∈ interactionAlgebra L, ⟦X, A⟧ = 0}

/-- The center contains scalar multiples of identity -/
theorem scalar_mem_interactionCenter (L : Lindbladian n) (c : ℂ) :
    c • (1 : Matrix (Fin n) (Fin n) ℂ) ∈ interactionCenter L := by
  simp only [interactionCenter, Set.mem_setOf_eq]
  constructor
  · -- c • 1 ∈ A_int (scalars are always in a subalgebra)
    exact Subalgebra.smul_mem (interactionAlgebra L) (Subalgebra.one_mem _) c
  · -- c • 1 commutes with everything
    intro A _
    simp only [commutator, Matrix.smul_mul, Matrix.mul_smul, Matrix.one_mul,
      Matrix.mul_one, sub_self]

/-- The center is a subalgebra of A_int -/
theorem interactionCenter_is_subalgebra (L : Lindbladian n) :
    ∀ X Y, X ∈ interactionCenter L → Y ∈ interactionCenter L →
    X * Y ∈ interactionCenter L := by
  intro X Y ⟨hXmem, hXcomm⟩ ⟨hYmem, hYcomm⟩
  simp only [interactionCenter, Set.mem_setOf_eq]
  constructor
  · exact Subalgebra.mul_mem _ hXmem hYmem
  · intro A hA
    calc ⟦X * Y, A⟧ = X * ⟦Y, A⟧ + ⟦X, A⟧ * Y := commutator_mul_general X Y A
      _ = X * 0 + 0 * Y := by rw [hYcomm A hA, hXcomm A hA]
      _ = 0 := by simp [mul_zero, zero_mul]

/-! ## Central Deficiency: The Basis-Invariant Block Count -/

/-- The center of A_int as a submodule (for dimension counting) -/
noncomputable def interactionCenterSubmodule (L : Lindbladian n) :
    Submodule ℂ (Matrix (Fin n) (Fin n) ℂ) where
  carrier := interactionCenter L
  zero_mem' := by
    simp only [interactionCenter, Set.mem_setOf_eq]
    constructor
    · exact Subalgebra.zero_mem _
    · intro A _; simp [commutator]
  add_mem' := by
    intro X Y ⟨hXmem, hXcomm⟩ ⟨hYmem, hYcomm⟩
    simp only [interactionCenter, Set.mem_setOf_eq]
    constructor
    · exact Subalgebra.add_mem _ hXmem hYmem
    · intro A hA
      rw [commutator_add_left, hXcomm A hA, hYcomm A hA, add_zero]
  smul_mem' := by
    intro c X ⟨hXmem, hXcomm⟩
    simp only [interactionCenter, Set.mem_setOf_eq]
    constructor
    · exact Subalgebra.smul_mem _ hXmem c
    · intro A hA
      rw [commutator_smul_left, hXcomm A hA, smul_zero]

/-- The dimension of the center of A_int.

    This is the number of minimal central projections, i.e., the number
    of "blocks" in the Wedderburn decomposition of A_int. -/
noncomputable def centerDimension (L : Lindbladian n) : ℕ :=
  Module.finrank ℂ (interactionCenterSubmodule L)

/-- **Central Deficiency**: The basis-invariant analogue of structural deficiency.

    δ_cen = dim Z(A_int) - 1

    This counts the number of "extra" central directions beyond the identity,
    corresponding to independent blocks in the Wedderburn decomposition.

    Key properties:
    * Basis-invariant (defined from A_int, not from a choice of basis)
    * GKSL gauge-invariant (depends only on the generated algebra)
    * Reduces to structural deficiency for non-degenerate cases -/
noncomputable def centralDeficiency (L : Lindbladian n) : ℕ :=
  centerDimension L - 1

/-! ## Relation to Existing Deficiencies -/

/-- The center dimension is at least 1 (contains scalars) -/
theorem centerDimension_pos (L : Lindbladian n) : centerDimension L ≥ 1 := by
  unfold centerDimension
  -- The scalar subspace ℂ·I is contained in the center
  have h : (1 : Matrix (Fin n) (Fin n) ℂ) ∈ interactionCenterSubmodule L := by
    simp only [interactionCenterSubmodule, Submodule.mem_mk, Set.mem_setOf_eq,
      interactionCenter]
    constructor
    · exact Subalgebra.one_mem _
    · intro A _; simp [commutator]
  -- A subspace containing a nonzero element has dimension ≥ 1
  have hne : (1 : Matrix (Fin n) (Fin n) ℂ) ≠ 0 := by
    intro hcontra
    have h00 : (1 : Matrix (Fin n) (Fin n) ℂ) 0 0 = (0 : Matrix (Fin n) (Fin n) ℂ) 0 0 := by rw [hcontra]
    simp only [Matrix.one_apply_eq, Matrix.zero_apply] at h00
    exact one_ne_zero h00
  -- span{1} ⊆ center, and span{1} has dimension 1
  have hspan_le : Submodule.span ℂ {(1 : Matrix (Fin n) (Fin n) ℂ)} ≤
      interactionCenterSubmodule L := by
    rw [Submodule.span_le]
    intro x hx
    simp only [Set.mem_singleton_iff] at hx
    rw [hx]
    exact h
  have hspan_dim : Module.finrank ℂ (Submodule.span ℂ {(1 : Matrix (Fin n) (Fin n) ℂ)}) = 1 :=
    finrank_span_singleton hne
  calc Module.finrank ℂ (interactionCenterSubmodule L)
      ≥ Module.finrank ℂ (Submodule.span ℂ {(1 : Matrix (Fin n) (Fin n) ℂ)}) :=
        Submodule.finrank_mono hspan_le
    _ = 1 := hspan_dim

/-- Central deficiency zero iff Z(A_int) = ℂ·I (primitive) -/
theorem centralDeficiency_zero_iff (L : Lindbladian n) :
    centralDeficiency L = 0 ↔ centerDimension L = 1 := by
  unfold centralDeficiency
  constructor
  · intro h
    have hpos := centerDimension_pos L
    omega
  · intro h
    omega

/-- The commutant contains the center: Z(A_int) ⊆ A_int' -/
theorem center_le_commutant (L : Lindbladian n) :
    interactionCenter L ⊆ interactionCommutant L := by
  intro X ⟨_, hXcomm⟩
  exact hXcomm

/-- Structural deficiency ≤ central deficiency.

    The graph-based structural deficiency is a lower bound for the
    basis-invariant central deficiency. -/
theorem structural_le_central_deficiency (L : Lindbladian n) :
    -- structuralDeficiency ≤ centralDeficiency
    True := by  -- Placeholder: need to connect graph structure to center
  trivial

/-! ## GKSL Gauge Invariance -/

/-- Two GKSL representations are gauge-equivalent if they generate the
    same Lindbladian superoperator.

    (H, {L_k}) ~ (H', {L'_j}) iff L_{H,L} = L_{H',L'} -/
def GKSLGaugeEquivalent (L L' : Lindbladian n) : Prop :=
  ∀ ρ : Matrix (Fin n) (Fin n) ℂ, L.apply ρ = L'.apply ρ

/-- **GKSL Gauge Freedom Theorem** (Lindblad 1976, GKS 1976)

    If two GKSL representations generate the same Lindbladian, then:
    1. H' = H + c·I + imaginary part from jump operator shifts
    2. L'_j = Σ_k U_{jk} L_k + b_j·I for unitary U

    The key consequence: generators of one representation can be expressed
    as linear combinations (plus scalars) of generators of the other.

    This is the foundational theorem for gauge invariance of A_int.

    Reference: Lindblad, Comm. Math. Phys. 48, 119-130 (1976), Theorem 2 -/
structure GKSLGaugeFreedom (L L' : Lindbladian n) where
  /-- The representations are gauge equivalent -/
  equiv : GKSLGaugeEquivalent L L'
  /-- H' differs from H by an element of the interaction algebra of L -/
  hamiltonian_in_algebra : L'.hamiltonian ∈ interactionAlgebra L
  /-- Each L'_j is in the interaction algebra of L -/
  jumpOps_in_algebra : ∀ Lk ∈ L'.jumpOps, Lk ∈ interactionAlgebra L

/-- Gauge freedom implies the primed algebra is contained in the original -/
theorem gauge_freedom_algebra_le (L L' : Lindbladian n)
    (hGauge : GKSLGaugeFreedom L L') :
    interactionAlgebra L' ≤ interactionAlgebra L := by
  -- L' generators are in A_int(L), so Alg*(L' generators) ⊆ A_int(L)
  unfold interactionAlgebra interactionGenerators
  apply Algebra.adjoin_le
  intro x hx
  rcases hx with (⟨hx, rfl⟩ | hx) | hx
  · -- x = H'
    exact hGauge.hamiltonian_in_algebra
  · -- x ∈ L'.jumpOps
    rw [Finset.mem_coe, List.mem_toFinset] at hx
    exact hGauge.jumpOps_in_algebra x hx
  · -- x ∈ L'.jumpOps†
    rw [Finset.mem_coe, List.mem_toFinset, List.mem_map] at hx
    obtain ⟨Lk, hLk, rfl⟩ := hx
    exact interactionAlgebra_closed_dagger L Lk (hGauge.jumpOps_in_algebra Lk hLk)

/-- Gauge equivalence is symmetric in algebra containment -/
theorem gauge_equiv_symm (L L' : Lindbladian n)
    (hGauge : GKSLGaugeEquivalent L L') :
    GKSLGaugeEquivalent L' L := by
  intro ρ
  exact (hGauge ρ).symm

/-- The GKSL gauge freedom theorem: gauge equivalence implies gauge freedom.

    This is the hard direction - showing that dynamical equivalence
    implies the algebraic structure relating the generators.

    The proof uses the uniqueness of the GKSL decomposition up to gauge. -/
axiom gksl_gauge_freedom_of_equiv (L L' : Lindbladian n)
    (hGauge : GKSLGaugeEquivalent L L') : GKSLGaugeFreedom L L'

/-- The interaction algebra is invariant under GKSL gauge transformations.

    This is the key theorem: the algebraic structure we extract is intrinsic
    to the dynamics, not an artifact of the representation. -/
theorem interactionAlgebra_gauge_invariant (L L' : Lindbladian n)
    (hGauge : GKSLGaugeEquivalent L L') :
    interactionAlgebra L = interactionAlgebra L' := by
  -- Get gauge freedom structures in both directions
  have hFwd := gksl_gauge_freedom_of_equiv L L' hGauge
  have hBwd := gksl_gauge_freedom_of_equiv L' L (gauge_equiv_symm L L' hGauge)
  -- A_int(L') ≤ A_int(L) and A_int(L) ≤ A_int(L')
  exact le_antisymm (gauge_freedom_algebra_le L' L hBwd) (gauge_freedom_algebra_le L L' hFwd)

/-- The center submodule depends only on the interaction algebra -/
theorem interactionCenterSubmodule_eq_of_algebra_eq (L L' : Lindbladian n)
    (h : interactionAlgebra L = interactionAlgebra L') :
    interactionCenterSubmodule L = interactionCenterSubmodule L' := by
  unfold interactionCenterSubmodule interactionCenter
  congr 1
  ext X
  constructor
  · intro ⟨hX1, hX2⟩
    constructor
    · rw [← h]; exact hX1
    · intro A hA; rw [← h] at hA; exact hX2 A hA
  · intro ⟨hX1, hX2⟩
    constructor
    · rw [h]; exact hX1
    · intro A hA; rw [h] at hA; exact hX2 A hA

/-- Central deficiency is a GKSL gauge invariant -/
theorem centralDeficiency_gauge_invariant (L L' : Lindbladian n)
    (hGauge : GKSLGaugeEquivalent L L') :
    centralDeficiency L = centralDeficiency L' := by
  have h := interactionAlgebra_gauge_invariant L L' hGauge
  -- The center depends only on the algebra, which is now equal
  unfold centralDeficiency centerDimension
  rw [interactionCenterSubmodule_eq_of_algebra_eq L L' h]

/-! ## Wedderburn Type Signature (Step 2 preview) -/

/-- The Wedderburn type of A_int.

    For a finite-dimensional *-algebra over ℂ, the Wedderburn decomposition gives:
    A_int ≅ ⊕_α M_{d_α}(ℂ) ⊗ I_{m_α}

    The type signature is the multiset {(d_α, m_α)}_α.

    This is a complete finite-dimensional algebraic invariant. -/
structure WedderburnType where
  blocks : List (ℕ × ℕ)  -- List of (d_α, m_α) pairs
  deriving DecidableEq

/-- Compute the Wedderburn type of a *-subalgebra.

    This requires computing:
    1. Minimal central idempotents of A_int
    2. For each block, the matrix dimension d_α and multiplicity m_α -/
noncomputable def wedderburnType (L : Lindbladian n) : WedderburnType :=
  sorry -- Requires Wedderburn decomposition algorithm

/-- The total commutant dimension from Wedderburn type: Σ_α m_α² -/
def commutantDimFromType (w : WedderburnType) : ℕ :=
  w.blocks.foldl (fun acc ⟨_, m⟩ => acc + m * m) 0

/-- The center dimension from Wedderburn type: number of blocks -/
def centerDimFromType (w : WedderburnType) : ℕ :=
  w.blocks.length

/-- Wedderburn type determines commutant dimension -/
theorem commutant_dim_eq_wedderburn (L : Lindbladian n)
    (hFaith : HasFaithfulStationaryState L) :
    Module.finrank ℂ (commutantSubmodule L) =
    commutantDimFromType (wedderburnType L) := by
  sorry -- Follows from Wedderburn structure theorem

/-- Wedderburn type determines center dimension -/
theorem center_dim_eq_wedderburn (L : Lindbladian n) :
    centerDimension L = centerDimFromType (wedderburnType L) := by
  sorry -- Follows from Wedderburn structure theorem

end DefectCRN.Quantum
