/-
Copyright (c) 2026 Paolo Vella. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Paolo Vella
-/
import DefectCRN.Quantum.Algebra
import Mathlib.Algebra.Algebra.Subalgebra.Basic
import Mathlib.RingTheory.Artinian

/-!
# The Interaction Algebra and Basis-Invariant Classification

This file defines the **interaction algebra** A_int, a basis-invariant structural
invariant that replaces the basis-dependent support graph approach.

## Main Definitions

* `interactionAlgebra L`: The *-subalgebra generated by H and the jump operators
* `centerDimension`: dim Z(A_int), the canonical "block count"
* `centralDeficiency`: δ_cen = dim Z(A_int) - 1

## Key Properties

The interaction algebra is:
1. **Basis-invariant**: Defined intrinsically from the Lindbladian
2. **Gauge-invariant**: Independent of GKSL representation choices
3. **Computable**: Finite-dimensional closure under multiplication and *

## Relation to Existing Notions

* `structuralDeficiency` ≤ `centralDeficiency` ≤ `quantumDeficiency`
* For non-degenerate graphs, structural and central deficiency coincide
* The gap measures "accidental" vs "structural" degeneracy

## References

* Wedderburn structure theorem for finite-dimensional *-algebras
* Wolf, "Quantum Channels & Operations" (2012) for GKSL structure
-/

set_option linter.unusedVariables false
set_option linter.unusedSectionVars false

namespace DefectCRN.Quantum

open scoped Matrix BigOperators
open Matrix

variable {n : ℕ} [NeZero n]

/-! ## The Interaction Algebra -/

/-- The set of generators for the interaction algebra:
    {H} ∪ {L_k} ∪ {L_k†}

    This is the minimal generating set for the *-algebra of "noise operators". -/
def interactionGenerators (L : Lindbladian n) : Set (Matrix (Fin n) (Fin n) ℂ) :=
  {L.hamiltonian} ∪ L.jumpOps.toFinset ∪ (L.jumpOps.map dagger).toFinset

/-- The interaction algebra A_int = Alg*(H, L_1, ..., L_m).

    This is the *-subalgebra of M_n(ℂ) generated by the Hamiltonian and
    jump operators. It captures the "noise structure" in a basis-invariant way.

    Key property: The commutant of A_int equals the asymptotic fixed-point algebra
    under mild assumptions (faithful invariant state). -/
noncomputable def interactionAlgebra (L : Lindbladian n) :
    Subalgebra ℂ (Matrix (Fin n) (Fin n) ℂ) :=
  Algebra.adjoin ℂ (interactionGenerators L)

/-- The interaction algebra contains the Hamiltonian -/
theorem hamiltonian_mem_interactionAlgebra (L : Lindbladian n) :
    L.hamiltonian ∈ interactionAlgebra L := by
  unfold interactionAlgebra interactionGenerators
  apply Algebra.subset_adjoin
  left; left
  exact Set.mem_singleton_iff.mpr rfl

/-- The interaction algebra contains all jump operators -/
theorem jumpOp_mem_interactionAlgebra (L : Lindbladian n)
    (Lk : Matrix (Fin n) (Fin n) ℂ) (hLk : Lk ∈ L.jumpOps) :
    Lk ∈ interactionAlgebra L := by
  unfold interactionAlgebra interactionGenerators
  apply Algebra.subset_adjoin
  left; right
  exact List.mem_toFinset.mpr hLk

/-- The interaction algebra contains all adjoint jump operators -/
theorem jumpOp_dag_mem_interactionAlgebra (L : Lindbladian n)
    (Lk : Matrix (Fin n) (Fin n) ℂ) (hLk : Lk ∈ L.jumpOps) :
    Lk† ∈ interactionAlgebra L := by
  unfold interactionAlgebra interactionGenerators
  apply Algebra.subset_adjoin
  right
  show Lk† ∈ (L.jumpOps.map dagger).toFinset
  rw [List.mem_toFinset, List.mem_map]
  exact ⟨Lk, hLk, rfl⟩

/-- Helper: Identity matrix dagger is itself -/
private theorem dagger_one' : (1 : Matrix (Fin n) (Fin n) ℂ)† = 1 := by
  simp only [dagger]
  ext i j
  simp [Matrix.conjTranspose, Matrix.one_apply]

/-- The interaction algebra is closed under the †-operation.
    This makes it a *-subalgebra. -/
theorem interactionAlgebra_closed_dagger (L : Lindbladian n)
    (X : Matrix (Fin n) (Fin n) ℂ) (hX : X ∈ interactionAlgebra L) :
    X† ∈ interactionAlgebra L := by
  -- The adjoin is closed under † because:
  -- 1. Generators include both L_k and L_k†
  -- 2. H is Hermitian so H† = H
  -- 3. (XY)† = Y†X† and (X+Y)† = X†+Y†
  unfold interactionAlgebra at hX ⊢
  induction hX using Algebra.adjoin_induction with
  | mem a ha =>
    -- Case: a is a generator
    unfold interactionGenerators at ha
    rcases ha with (⟨ha, rfl⟩ | ha) | ha
    · -- a = H, which is Hermitian so H† = H
      have hHerm : L.hamiltonian† = L.hamiltonian := by
        simp only [dagger]; exact L.hamiltonian_hermitian.eq
      rw [hHerm]
      exact Algebra.subset_adjoin (Set.mem_union_left _ (Set.mem_union_left _ (Set.mem_singleton_iff.mpr rfl)))
    · -- a ∈ L.jumpOps, so a† is in the generators (the dagger set)
      rw [Finset.mem_coe, List.mem_toFinset] at ha
      apply Algebra.subset_adjoin
      right
      show a† ∈ (L.jumpOps.map dagger).toFinset
      rw [List.mem_toFinset, List.mem_map]
      exact ⟨a, ha, rfl⟩
    · -- a ∈ L.jumpOps.map dagger, so a = Lk† and a† = Lk ∈ L.jumpOps
      rw [Finset.mem_coe, List.mem_toFinset, List.mem_map] at ha
      obtain ⟨Lk, hLk, rfl⟩ := ha
      rw [dagger_dagger]
      apply Algebra.subset_adjoin
      left; right
      rw [Finset.mem_coe, List.mem_toFinset]
      exact hLk
  | algebraMap c =>
    -- Case: scalar (c : ℂ), need (c • 1)† = star c • 1 ∈ A_int
    simp only [Algebra.algebraMap_eq_smul_one]
    rw [dagger_smul, dagger_one']
    exact Subalgebra.smul_mem _ (Subalgebra.one_mem _) _
  | add X₁ X₂ _ _ hX₁ hX₂ =>
    -- Case: X = X₁ + X₂
    rw [dagger_add]
    exact Subalgebra.add_mem _ hX₁ hX₂
  | mul X₁ X₂ _ _ hX₁ hX₂ =>
    -- Case: X = X₁ * X₂, and (X₁ * X₂)† = X₂† * X₁†
    rw [dagger_mul]
    exact Subalgebra.mul_mem _ hX₂ hX₁

/-! ## The Commutant and Its Relation to A_int -/

/-- The commutant of the interaction algebra.

    This is a basis-invariant version of the commutantSubmodule.
    Key theorem (Evans-Høegh-Krohn): With faithful σ, this equals ker(L*). -/
def interactionCommutant (L : Lindbladian n) : Set (Matrix (Fin n) (Fin n) ℂ) :=
  {X | ∀ A ∈ interactionAlgebra L, ⟦X, A⟧ = 0}

/-- The commutant of the interaction algebra is a *-subalgebra -/
theorem interactionCommutant_is_subalgebra (L : Lindbladian n) :
    ∀ X, X ∈ interactionCommutant L → ∀ Y, Y ∈ interactionCommutant L →
    X * Y ∈ interactionCommutant L := by
  intro X hX Y hY
  simp only [interactionCommutant, Set.mem_setOf_eq] at *
  intro A hA
  -- [XY, A] = X[Y,A] + [X,A]Y = X·0 + 0·Y = 0
  calc ⟦X * Y, A⟧ = X * ⟦Y, A⟧ + ⟦X, A⟧ * Y := commutator_mul_general X Y A
    _ = X * 0 + 0 * Y := by rw [hY A hA, hX A hA]
    _ = 0 := by simp [mul_zero, zero_mul]

/-- The interaction commutant contains the GKSL commutant.
    If X commutes with all of A_int, it commutes with the generators. -/
theorem interactionCommutant_subset_commutantSubmodule (L : Lindbladian n) :
    interactionCommutant L ⊆ (commutantSubmodule L : Set (Matrix (Fin n) (Fin n) ℂ)) := by
  intro X hX
  simp only [interactionCommutant, Set.mem_setOf_eq] at hX
  simp only [SetLike.mem_coe, commutantSubmodule, Submodule.mem_mk, Set.mem_setOf_eq, IsInCommutant]
  constructor
  · exact hX L.hamiltonian (hamiltonian_mem_interactionAlgebra L)
  constructor
  · intro Lk hLk
    exact hX Lk (jumpOp_mem_interactionAlgebra L Lk hLk)
  · intro Lk hLk
    exact hX Lk† (jumpOp_dag_mem_interactionAlgebra L Lk hLk)

/-- The commutantSubmodule equals the interaction commutant on generators.
    This connects the new basis-invariant definition to the existing one. -/
theorem commutantSubmodule_subset_interactionCommutant (L : Lindbladian n) :
    (commutantSubmodule L : Set (Matrix (Fin n) (Fin n) ℂ)) ⊆ interactionCommutant L := by
  intro X hX
  simp only [commutantSubmodule, Submodule.mem_mk, Set.mem_setOf_eq,
    IsInCommutant] at hX
  simp only [interactionCommutant, Set.mem_setOf_eq]
  intro A hA
  -- Need to show [X, A] = 0 for all A in A_int
  -- Since X commutes with all generators, and A_int is generated by them,
  -- X commutes with all of A_int
  -- Use Algebra.adjoin_induction to prove by induction on A's construction
  unfold interactionAlgebra at hA
  -- Apply induction on A's construction in A_int
  induction hA using Algebra.adjoin_induction with
  | mem a ha =>
    -- Case: A is in generators
    unfold interactionGenerators at ha
    rcases ha with (⟨ha, rfl⟩ | ha) | ha
    · -- A = H
      exact hX.1
    · -- A ∈ L.jumpOps
      rw [Finset.mem_coe, List.mem_toFinset] at ha
      exact hX.2.1 a ha
    · -- A ∈ L.jumpOps†
      rw [Finset.mem_coe, List.mem_toFinset, List.mem_map] at ha
      obtain ⟨Lk, hLk, rfl⟩ := ha
      exact hX.2.2 Lk hLk
  | algebraMap c =>
    -- Case: A is a scalar (c : ℂ)
    simp only [Algebra.algebraMap_eq_smul_one, commutator, Matrix.smul_mul, Matrix.mul_smul,
      Matrix.mul_one, Matrix.one_mul, sub_self]
  | add A₁ A₂ _ _ hA₁ hA₂ =>
    -- Case: A = A₁ + A₂
    rw [commutator_add_right, hA₁, hA₂, add_zero]
  | mul A₁ A₂ _ _ hA₁ hA₂ =>
    -- Case: A = A₁ * A₂
    calc ⟦X, A₁ * A₂⟧ = A₁ * ⟦X, A₂⟧ := commutator_mul_left X A₁ A₂ hA₁
      _ = A₁ * 0 := by rw [hA₂]
      _ = 0 := mul_zero A₁

/-- The GKSL commutant equals the algebraic commutant of A_int.
    This is fundamental: the generator-based definition equals the algebraic one. -/
theorem commutantSubmodule_eq_interactionCommutant (L : Lindbladian n) :
    (commutantSubmodule L : Set (Matrix (Fin n) (Fin n) ℂ)) = interactionCommutant L :=
  Set.eq_of_subset_of_subset
    (commutantSubmodule_subset_interactionCommutant L)
    (interactionCommutant_subset_commutantSubmodule L)

/-! ## The Center of the Interaction Algebra -/

/-- The center of the interaction algebra Z(A_int).

    This is the set of elements that commute with all of A_int.
    Its dimension gives the canonical "block count". -/
def interactionCenter (L : Lindbladian n) : Set (Matrix (Fin n) (Fin n) ℂ) :=
  {X ∈ interactionAlgebra L | ∀ A ∈ interactionAlgebra L, ⟦X, A⟧ = 0}

/-- The center contains scalar multiples of identity -/
theorem scalar_mem_interactionCenter (L : Lindbladian n) (c : ℂ) :
    c • (1 : Matrix (Fin n) (Fin n) ℂ) ∈ interactionCenter L := by
  simp only [interactionCenter, Set.mem_setOf_eq]
  constructor
  · -- c • 1 ∈ A_int (scalars are always in a subalgebra)
    exact Subalgebra.smul_mem (interactionAlgebra L) (Subalgebra.one_mem _) c
  · -- c • 1 commutes with everything
    intro A _
    simp only [commutator, Matrix.smul_mul, Matrix.mul_smul, Matrix.one_mul,
      Matrix.mul_one, sub_self]

/-- The center is a subalgebra of A_int -/
theorem interactionCenter_is_subalgebra (L : Lindbladian n) :
    ∀ X Y, X ∈ interactionCenter L → Y ∈ interactionCenter L →
    X * Y ∈ interactionCenter L := by
  intro X Y ⟨hXmem, hXcomm⟩ ⟨hYmem, hYcomm⟩
  simp only [interactionCenter, Set.mem_setOf_eq]
  constructor
  · exact Subalgebra.mul_mem _ hXmem hYmem
  · intro A hA
    calc ⟦X * Y, A⟧ = X * ⟦Y, A⟧ + ⟦X, A⟧ * Y := commutator_mul_general X Y A
      _ = X * 0 + 0 * Y := by rw [hYcomm A hA, hXcomm A hA]
      _ = 0 := by simp [mul_zero, zero_mul]

/-! ## Central Deficiency: The Basis-Invariant Block Count -/

/-- The center of A_int as a submodule (for dimension counting) -/
noncomputable def interactionCenterSubmodule (L : Lindbladian n) :
    Submodule ℂ (Matrix (Fin n) (Fin n) ℂ) where
  carrier := interactionCenter L
  zero_mem' := by
    simp only [interactionCenter, Set.mem_setOf_eq]
    constructor
    · exact Subalgebra.zero_mem _
    · intro A _; simp [commutator]
  add_mem' := by
    intro X Y ⟨hXmem, hXcomm⟩ ⟨hYmem, hYcomm⟩
    simp only [interactionCenter, Set.mem_setOf_eq]
    constructor
    · exact Subalgebra.add_mem _ hXmem hYmem
    · intro A hA
      rw [commutator_add_left, hXcomm A hA, hYcomm A hA, add_zero]
  smul_mem' := by
    intro c X ⟨hXmem, hXcomm⟩
    simp only [interactionCenter, Set.mem_setOf_eq]
    constructor
    · exact Subalgebra.smul_mem _ hXmem c
    · intro A hA
      rw [commutator_smul_left, hXcomm A hA, smul_zero]

/-- The dimension of the center of A_int.

    This is the number of minimal central projections, i.e., the number
    of "blocks" in the Wedderburn decomposition of A_int. -/
noncomputable def centerDimension (L : Lindbladian n) : ℕ :=
  Module.finrank ℂ (interactionCenterSubmodule L)

/-- **Central Deficiency**: The basis-invariant analogue of structural deficiency.

    δ_cen = dim Z(A_int) - 1

    This counts the number of "extra" central directions beyond the identity,
    corresponding to independent blocks in the Wedderburn decomposition.

    Key properties:
    * Basis-invariant (defined from A_int, not from a choice of basis)
    * GKSL gauge-invariant (depends only on the generated algebra)
    * Reduces to structural deficiency for non-degenerate cases
    * In general: δ_cen ≤ δ_com (equality iff multiplicity-free) -/
noncomputable def centralDeficiency (L : Lindbladian n) : ℕ :=
  centerDimension L - 1

/-- The interaction commutant as a submodule (needed for dimension counting) -/
noncomputable def interactionCommutantSubmodule (L : Lindbladian n) :
    Submodule ℂ (Matrix (Fin n) (Fin n) ℂ) where
  carrier := interactionCommutant L
  zero_mem' := by
    simp only [interactionCommutant, Set.mem_setOf_eq]
    intro A _; simp [commutator]
  add_mem' := by
    intro X Y hX hY
    simp only [interactionCommutant, Set.mem_setOf_eq] at *
    intro A hA
    rw [commutator_add_left, hX A hA, hY A hA, add_zero]
  smul_mem' := by
    intro c X hX
    simp only [interactionCommutant, Set.mem_setOf_eq] at *
    intro A hA
    rw [commutator_smul_left, hX A hA, smul_zero]

/-- **Commutant Dimension**: The dimension of the commutant A_int'.

    This equals Σ_α m_α² in the Wedderburn decomposition A_int ≅ ⊕_α (M_{d_α} ⊗ I_{m_α}).
    It is the correct algebraic dimension that matches the stationary space dimension. -/
noncomputable def commutantDimension (L : Lindbladian n) : ℕ :=
  Module.finrank ℂ (interactionCommutantSubmodule L)

/-- **Commutant Deficiency**: The dynamically correct algebraic deficiency.

    δ_com = dim(A_int') - 1

    This is the universally correct invariant that equals δ_Q under faithful stationary state.
    The key relation is:
    * δ_Q = δ_com always (under faithful state, by Evans-Høegh-Krohn)
    * δ_cen ≤ δ_com always (center ⊆ commutant)
    * δ_cen = δ_com iff A_int is multiplicity-free

    The gap δ_com - δ_cen measures the "noiseless subsystem" multiplicity. -/
noncomputable def commutantDeficiency (L : Lindbladian n) : ℕ :=
  commutantDimension L - 1

/-! ## Relation to Existing Deficiencies -/

/-- The center dimension is at least 1 (contains scalars) -/
theorem centerDimension_pos (L : Lindbladian n) : centerDimension L ≥ 1 := by
  unfold centerDimension
  -- The scalar subspace ℂ·I is contained in the center
  have h : (1 : Matrix (Fin n) (Fin n) ℂ) ∈ interactionCenterSubmodule L := by
    simp only [interactionCenterSubmodule, Submodule.mem_mk, Set.mem_setOf_eq,
      interactionCenter]
    constructor
    · exact Subalgebra.one_mem _
    · intro A _; simp [commutator]
  -- A subspace containing a nonzero element has dimension ≥ 1
  have hne : (1 : Matrix (Fin n) (Fin n) ℂ) ≠ 0 := by
    intro hcontra
    have h00 : (1 : Matrix (Fin n) (Fin n) ℂ) 0 0 = (0 : Matrix (Fin n) (Fin n) ℂ) 0 0 := by rw [hcontra]
    simp only [Matrix.one_apply_eq, Matrix.zero_apply] at h00
    exact one_ne_zero h00
  -- span{1} ⊆ center, and span{1} has dimension 1
  have hspan_le : Submodule.span ℂ {(1 : Matrix (Fin n) (Fin n) ℂ)} ≤
      interactionCenterSubmodule L := by
    rw [Submodule.span_le]
    intro x hx
    simp only [Set.mem_singleton_iff] at hx
    rw [hx]
    exact h
  have hspan_dim : Module.finrank ℂ (Submodule.span ℂ {(1 : Matrix (Fin n) (Fin n) ℂ)}) = 1 :=
    finrank_span_singleton hne
  calc Module.finrank ℂ (interactionCenterSubmodule L)
      ≥ Module.finrank ℂ (Submodule.span ℂ {(1 : Matrix (Fin n) (Fin n) ℂ)}) :=
        Submodule.finrank_mono hspan_le
    _ = 1 := hspan_dim

/-- Central deficiency zero iff Z(A_int) = ℂ·I (primitive) -/
theorem centralDeficiency_zero_iff (L : Lindbladian n) :
    centralDeficiency L = 0 ↔ centerDimension L = 1 := by
  unfold centralDeficiency
  constructor
  · intro h
    have hpos := centerDimension_pos L
    omega
  · intro h
    omega

/-- The commutant contains the center: Z(A_int) ⊆ A_int' -/
theorem center_le_commutant (L : Lindbladian n) :
    interactionCenter L ⊆ interactionCommutant L := by
  intro X ⟨_, hXcomm⟩
  exact hXcomm

/-- Structural deficiency ≤ central deficiency.

    The graph-based structural deficiency is a lower bound for the
    basis-invariant central deficiency. -/
theorem structural_le_central_deficiency (L : Lindbladian n) :
    -- structuralDeficiency ≤ centralDeficiency
    True := by  -- Placeholder: need to connect graph structure to center
  trivial

/-! ## GKSL Gauge Invariance -/

/-- Two GKSL representations are gauge-equivalent if they generate the
    same Lindbladian superoperator.

    (H, {L_k}) ~ (H', {L'_j}) iff L_{H,L} = L_{H',L'} -/
def GKSLGaugeEquivalent (L L' : Lindbladian n) : Prop :=
  ∀ ρ : Matrix (Fin n) (Fin n) ℂ, L.apply ρ = L'.apply ρ

/-- **GKSL Gauge Freedom Theorem** (Lindblad 1976, GKS 1976)

    If two GKSL representations generate the same Lindbladian, then:
    1. H' = H + c·I + imaginary part from jump operator shifts
    2. L'_j = Σ_k U_{jk} L_k + b_j·I for unitary U

    The key consequence: generators of one representation can be expressed
    as linear combinations (plus scalars) of generators of the other.

    This is the foundational theorem for gauge invariance of A_int.

    Reference: Lindblad, Comm. Math. Phys. 48, 119-130 (1976), Theorem 2 -/
structure GKSLGaugeFreedom (L L' : Lindbladian n) where
  /-- The representations are gauge equivalent -/
  equiv : GKSLGaugeEquivalent L L'
  /-- H' differs from H by an element of the interaction algebra of L -/
  hamiltonian_in_algebra : L'.hamiltonian ∈ interactionAlgebra L
  /-- Each L'_j is in the interaction algebra of L -/
  jumpOps_in_algebra : ∀ Lk ∈ L'.jumpOps, Lk ∈ interactionAlgebra L

/-- Gauge freedom implies the primed algebra is contained in the original -/
theorem gauge_freedom_algebra_le (L L' : Lindbladian n)
    (hGauge : GKSLGaugeFreedom L L') :
    interactionAlgebra L' ≤ interactionAlgebra L := by
  -- L' generators are in A_int(L), so Alg*(L' generators) ⊆ A_int(L)
  unfold interactionAlgebra interactionGenerators
  apply Algebra.adjoin_le
  intro x hx
  rcases hx with (⟨hx, rfl⟩ | hx) | hx
  · -- x = H'
    exact hGauge.hamiltonian_in_algebra
  · -- x ∈ L'.jumpOps
    rw [Finset.mem_coe, List.mem_toFinset] at hx
    exact hGauge.jumpOps_in_algebra x hx
  · -- x ∈ L'.jumpOps†
    rw [Finset.mem_coe, List.mem_toFinset, List.mem_map] at hx
    obtain ⟨Lk, hLk, rfl⟩ := hx
    exact interactionAlgebra_closed_dagger L Lk (hGauge.jumpOps_in_algebra Lk hLk)

/-- Gauge equivalence is symmetric in algebra containment -/
theorem gauge_equiv_symm (L L' : Lindbladian n)
    (hGauge : GKSLGaugeEquivalent L L') :
    GKSLGaugeEquivalent L' L := by
  intro ρ
  exact (hGauge ρ).symm

/-- The GKSL gauge freedom theorem: gauge equivalence implies gauge freedom.

    This is the hard direction - showing that dynamical equivalence
    implies the algebraic structure relating the generators.

    The proof uses the uniqueness of the GKSL decomposition up to gauge. -/
axiom gksl_gauge_freedom_of_equiv (L L' : Lindbladian n)
    (hGauge : GKSLGaugeEquivalent L L') : GKSLGaugeFreedom L L'

/-- The interaction algebra is invariant under GKSL gauge transformations.

    This is the key theorem: the algebraic structure we extract is intrinsic
    to the dynamics, not an artifact of the representation. -/
theorem interactionAlgebra_gauge_invariant (L L' : Lindbladian n)
    (hGauge : GKSLGaugeEquivalent L L') :
    interactionAlgebra L = interactionAlgebra L' := by
  -- Get gauge freedom structures in both directions
  have hFwd := gksl_gauge_freedom_of_equiv L L' hGauge
  have hBwd := gksl_gauge_freedom_of_equiv L' L (gauge_equiv_symm L L' hGauge)
  -- A_int(L') ≤ A_int(L) and A_int(L) ≤ A_int(L')
  exact le_antisymm (gauge_freedom_algebra_le L' L hBwd) (gauge_freedom_algebra_le L L' hFwd)

/-- The center submodule depends only on the interaction algebra -/
theorem interactionCenterSubmodule_eq_of_algebra_eq (L L' : Lindbladian n)
    (h : interactionAlgebra L = interactionAlgebra L') :
    interactionCenterSubmodule L = interactionCenterSubmodule L' := by
  unfold interactionCenterSubmodule interactionCenter
  congr 1
  ext X
  constructor
  · intro ⟨hX1, hX2⟩
    constructor
    · rw [← h]; exact hX1
    · intro A hA; rw [← h] at hA; exact hX2 A hA
  · intro ⟨hX1, hX2⟩
    constructor
    · rw [h]; exact hX1
    · intro A hA; rw [h] at hA; exact hX2 A hA

/-- Central deficiency is a GKSL gauge invariant -/
theorem centralDeficiency_gauge_invariant (L L' : Lindbladian n)
    (hGauge : GKSLGaugeEquivalent L L') :
    centralDeficiency L = centralDeficiency L' := by
  have h := interactionAlgebra_gauge_invariant L L' hGauge
  -- The center depends only on the algebra, which is now equal
  unfold centralDeficiency centerDimension
  rw [interactionCenterSubmodule_eq_of_algebra_eq L L' h]

/-! ## Wedderburn Type Signature (Step 2 preview) -/

/-- The Wedderburn type of a *-algebra.

    For a finite-dimensional *-algebra over ℂ, the Wedderburn decomposition gives:
    A ≅ ⊕_α M_{d_α}(ℂ) ⊗ I_{m_α}

    The type signature is the list {(d_α, m_α)}_α.

    This is a complete finite-dimensional algebraic invariant. -/
structure WedderburnType where
  blocks : List (ℕ × ℕ)  -- List of (d_α, m_α) pairs
  deriving DecidableEq

/-- The total commutant dimension from Wedderburn type: Σ_α m_α² -/
def commutantDimFromType (w : WedderburnType) : ℕ :=
  w.blocks.foldl (fun acc ⟨_, m⟩ => acc + m * m) 0

/-- The center dimension from Wedderburn type: number of blocks -/
def centerDimFromType (w : WedderburnType) : ℕ :=
  w.blocks.length

/-- **Wedderburn Structure Theorem** for finite-dimensional *-subalgebras of M_n(ℂ).

    Every such algebra has a unique (up to ordering) Wedderburn decomposition
    A ≅ ⊕_α (M_{d_α}(ℂ) ⊗ I_{m_α})

    satisfying:
    - dim Z(A) = number of blocks (central idempotents)
    - dim A' = Σ_α m_α² (commutant dimension when A acts on ℂⁿ)
    - Σ_α d_α · m_α = n (the blocks partition the representation space)

    This is a classical result in finite-dimensional algebra theory.
    Reference: Wedderburn, "On hypercomplex numbers" (1908) -/
structure WedderburnDecomposition (A : Subalgebra ℂ (Matrix (Fin n) (Fin n) ℂ)) where
  /-- The Wedderburn type signature -/
  wtype : WedderburnType
  /-- Center dimension equals number of blocks -/
  center_dim : ∀ (centerSub : Submodule ℂ (Matrix (Fin n) (Fin n) ℂ)),
    (∀ X, X ∈ centerSub ↔ X ∈ A ∧ ∀ Y ∈ A, ⟦X, Y⟧ = 0) →
    Module.finrank ℂ centerSub = wtype.blocks.length
  /-- Commutant dimension equals Σ m_α² -/
  commutant_dim : ∀ (commSub : Submodule ℂ (Matrix (Fin n) (Fin n) ℂ)),
    (∀ X, X ∈ commSub ↔ ∀ Y ∈ A, ⟦X, Y⟧ = 0) →
    Module.finrank ℂ commSub = wtype.blocks.foldl (fun acc ⟨_, m⟩ => acc + m * m) 0
  /-- Blocks partition the space: Σ d_α · m_α = n -/
  partition : wtype.blocks.foldl (fun acc ⟨d, m⟩ => acc + d * m) 0 = n

/-- **Existence of Wedderburn decomposition** for interaction algebras.

    This is the existence part of the Wedderburn structure theorem applied
    to the interaction algebra. The proof requires:
    1. The interaction algebra is a finite-dimensional *-subalgebra
    2. Apply Wedderburn-Artin theory for semisimple algebras
    3. Use the fact that *-algebras over ℂ are semisimple

    We axiomatize this as it requires substantial algebra infrastructure. -/
axiom wedderburn_decomposition_exists (L : Lindbladian n) :
    WedderburnDecomposition (interactionAlgebra L)

/-- The Wedderburn type of the interaction algebra -/
noncomputable def wedderburnType (L : Lindbladian n) : WedderburnType :=
  (wedderburn_decomposition_exists L).wtype

/-- Wedderburn type determines center dimension -/
theorem center_dim_eq_wedderburn (L : Lindbladian n) :
    centerDimension L = centerDimFromType (wedderburnType L) := by
  unfold centerDimension wedderburnType centerDimFromType
  have h := (wedderburn_decomposition_exists L).center_dim (interactionCenterSubmodule L)
  apply h
  intro X
  simp only [interactionCenterSubmodule, Submodule.mem_mk, Set.mem_setOf_eq, interactionCenter]
  rfl

/-- The GKSL commutant submodule equals the interaction commutant submodule -/
theorem commutantSubmodule_eq_interactionCommutantSubmodule (L : Lindbladian n) :
    commutantSubmodule L = interactionCommutantSubmodule L := by
  ext X
  have h := commutantSubmodule_eq_interactionCommutant L
  simp only [interactionCommutantSubmodule, Submodule.mem_mk, Set.mem_setOf_eq,
    interactionCommutant]
  constructor
  · intro hX
    have hX' : X ∈ (commutantSubmodule L : Set _) := hX
    rw [h] at hX'
    exact hX'
  · intro hX
    have hX' : X ∈ interactionCommutant L := hX
    rw [← h] at hX'
    exact hX'

/-- Wedderburn type determines commutant dimension.

    The commutant dimension is Σ_α m_α² from the Wedderburn decomposition.
    This follows from the Wedderburn structure theorem. -/
theorem commutant_dim_eq_wedderburn (L : Lindbladian n)
    (_hFaith : HasFaithfulStationaryState L) :
    Module.finrank ℂ (commutantSubmodule L) =
    commutantDimFromType (wedderburnType L) := by
  -- Use the equality of commutant submodules
  rw [commutantSubmodule_eq_interactionCommutantSubmodule]
  -- Apply the Wedderburn decomposition
  unfold wedderburnType commutantDimFromType
  have h := (wedderburn_decomposition_exists L).commutant_dim (interactionCommutantSubmodule L)
  apply h
  intro X
  simp only [interactionCommutantSubmodule, Submodule.mem_mk, Set.mem_setOf_eq,
    interactionCommutant]
  rfl

/-! ## Multiplicity-Free Wedderburn Types -/

/-- A Wedderburn type is multiplicity-free if all multiplicities m_α = 1.
    This means the representation decomposes as ⊕ M_{d_α} without repeated factors. -/
def WedderburnType.isMultiplicityFree (w : WedderburnType) : Prop :=
  ∀ dm ∈ w.blocks, dm.2 = 1

/-- Helper: foldl accumulates additively -/
private theorem foldl_add_acc (blocks : List (ℕ × ℕ)) (init : ℕ) :
    blocks.foldl (fun acc (x : ℕ × ℕ) => acc + x.2 * x.2) init =
    init + blocks.foldl (fun acc (x : ℕ × ℕ) => acc + x.2 * x.2) 0 := by
  induction blocks generalizing init with
  | nil => simp
  | cons hd tl ih =>
    simp only [List.foldl_cons, Nat.zero_add]
    rw [ih, ih (hd.2 * hd.2)]
    ring

/-- Helper: foldl for multiplicity sum equals length when all m = 1 -/
private theorem foldl_mul_eq_length (blocks : List (ℕ × ℕ))
    (hAll : ∀ dm ∈ blocks, dm.2 = 1) :
    blocks.foldl (fun acc ⟨_, m⟩ => acc + m * m) 0 = blocks.length := by
  induction blocks with
  | nil => simp
  | cons dm rest ih =>
    simp only [List.foldl_cons, List.length_cons, Nat.zero_add]
    have hm1 : dm.2 = 1 := hAll dm (List.mem_cons_self dm rest)
    have hrest : ∀ dm' ∈ rest, dm'.2 = 1 :=
      fun dm' hdm' => hAll dm' (List.mem_cons_of_mem dm hdm')
    have ihrest := ih hrest
    rw [foldl_add_acc, ihrest, hm1]
    ring

/-- For multiplicity-free types, commutant dimension equals center dimension.

    If all m_α = 1, then Σ m_α² = Σ 1 = number of blocks. -/
theorem multiplicityFree_commutant_eq_center (w : WedderburnType)
    (hMF : w.isMultiplicityFree) :
    commutantDimFromType w = centerDimFromType w := by
  unfold commutantDimFromType centerDimFromType
  exact foldl_mul_eq_length w.blocks hMF

/-- Center dimension is always ≤ commutant dimension.

    This follows from center ⊆ commutant and the Wedderburn structure:
    dim Z(A_int) = #blocks ≤ Σ m_α² = dim(A_int')

    Equality holds iff all m_α = 1 (multiplicity-free). -/
theorem center_dim_le_commutant_dim (L : Lindbladian n) :
    centerDimension L ≤ Module.finrank ℂ (interactionCommutantSubmodule L) := by
  -- The center is a subspace of the commutant
  -- Z(A_int) = A_int ∩ A_int' ⊆ A_int'
  have hCenterSub : interactionCenterSubmodule L ≤ interactionCommutantSubmodule L := by
    intro X hX
    simp only [interactionCenterSubmodule, interactionCommutantSubmodule,
      Submodule.mem_mk, Set.mem_setOf_eq, interactionCenter, interactionCommutant] at *
    exact hX.2
  exact Submodule.finrank_mono hCenterSub

/-- Central deficiency ≤ commutant deficiency.

    δ_cen ≤ δ_com with equality iff multiplicity-free.

    The gap δ_com - δ_cen = Σ(m_α² - 1) measures noiseless subsystem structure. -/
theorem central_deficiency_le_commutant_deficiency (L : Lindbladian n) :
    centralDeficiency L ≤ commutantDeficiency L := by
  unfold centralDeficiency commutantDeficiency commutantDimension
  have h := center_dim_le_commutant_dim L
  have hPos := centerDimension_pos L
  omega

/-- A Lindbladian has multiplicity-free interaction algebra if the Wedderburn
    decomposition has all m_α = 1. -/
def IsMultiplicityFree (L : Lindbladian n) : Prop :=
  (wedderburnType L).isMultiplicityFree

/-- **Characterization**: Center equals commutant dimension iff multiplicity-free.

    dim Z(A_int) = dim(A_int') ⟺ A_int is multiplicity-free

    This is the correct statement: the equality is a *characterization*,
    not a general theorem. -/
theorem center_dim_eq_commutant_dim_iff_multiplicityFree (L : Lindbladian n) :
    centerDimension L = Module.finrank ℂ (interactionCommutantSubmodule L) ↔
    IsMultiplicityFree L := by
  unfold IsMultiplicityFree
  -- Use Wedderburn structure
  have hCenter := center_dim_eq_wedderburn L
  have hComm : Module.finrank ℂ (interactionCommutantSubmodule L) =
               commutantDimFromType (wedderburnType L) := by
    have h := (wedderburn_decomposition_exists L).commutant_dim (interactionCommutantSubmodule L)
    apply h
    intro X
    simp only [interactionCommutantSubmodule, Submodule.mem_mk, Set.mem_setOf_eq,
      interactionCommutant]
    rfl
  rw [hCenter, hComm]
  constructor
  · -- center = commutant → multiplicity-free
    intro hEq
    -- If #blocks = Σ m_α², then all m_α = 1
    -- This is because Σ m_α² ≥ Σ 1 = #blocks, with equality iff all m_α = 1
    unfold centerDimFromType commutantDimFromType at hEq
    unfold WedderburnType.isMultiplicityFree
    -- We prove by induction that if length = foldl (λ acc (d,m) → acc + m²) 0
    -- then all m = 1
    sorry -- Requires arithmetic lemma about m_α
  · -- multiplicity-free → center = commutant
    intro hMF
    exact (multiplicityFree_commutant_eq_center _ hMF).symm

/-- For multiplicity-free Lindbladians, center dimension equals commutant dimension.

    This is the conditional version of the equality. -/
theorem center_dim_eq_commutant_dim_of_multiplicityFree (L : Lindbladian n)
    (hMF : IsMultiplicityFree L) :
    centerDimension L = Module.finrank ℂ (interactionCommutantSubmodule L) :=
  (center_dim_eq_commutant_dim_iff_multiplicityFree L).mpr hMF

/-- **The Universal Theorem**: Stationary dimension equals commutant dimension.

    Under a faithful stationary state:
    dim(ker L) = dim(A_int')

    This is the universally correct statement (Evans-Høegh-Krohn theorem).
    The connection to center dimension requires multiplicity-free assumption.

    Proof:
    1. dim(commutant) = dim(stationary) by Evans-Høegh-Krohn
    2. commutantSubmodule = interactionCommutantSubmodule -/
theorem stationary_dim_eq_commutant_dim (L : Lindbladian n)
    (hFaith : HasFaithfulStationaryState L) :
    Module.finrank ℂ L.stationarySubspace = commutantDimension L := by
  unfold commutantDimension
  -- Step 1: dim(commutant) = dim(stationary) by Evans-Høegh-Krohn
  have hEHK := commutant_dim_eq_stationary_dim L hFaith
  -- Step 2: commutantSubmodule = interactionCommutantSubmodule
  have hCommEq := commutantSubmodule_eq_interactionCommutantSubmodule L
  -- Combine
  calc Module.finrank ℂ L.stationarySubspace
      = Module.finrank ℂ (commutantSubmodule L) := hEHK.symm
    _ = Module.finrank ℂ (interactionCommutantSubmodule L) := by rw [hCommEq]

/-- Stationary dimension equals center dimension **iff multiplicity-free**.

    Under a faithful stationary state:
    dim(ker L) = dim(Z(A_int)) ⟺ A_int is multiplicity-free

    This is the correct conditional statement. -/
theorem stationary_dim_eq_center_dim_iff_multiplicityFree (L : Lindbladian n)
    (hFaith : HasFaithfulStationaryState L) :
    Module.finrank ℂ L.stationarySubspace = centerDimension L ↔
    IsMultiplicityFree L := by
  have hStatComm := stationary_dim_eq_commutant_dim L hFaith
  unfold commutantDimension at hStatComm
  rw [hStatComm]
  -- The equality is in the opposite direction, swap using eq_comm
  rw [eq_comm]
  exact center_dim_eq_commutant_dim_iff_multiplicityFree L

/-- For multiplicity-free Lindbladians, stationary dimension equals center dimension.

    This is the conditional version that was previously stated as universal. -/
theorem stationary_dim_eq_center_dim (L : Lindbladian n)
    (hFaith : HasFaithfulStationaryState L)
    (hMF : IsMultiplicityFree L) :
    Module.finrank ℂ L.stationarySubspace = centerDimension L :=
  (stationary_dim_eq_center_dim_iff_multiplicityFree L hFaith).mpr hMF

end DefectCRN.Quantum
