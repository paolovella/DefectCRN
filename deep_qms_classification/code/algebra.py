"""
Interaction Algebra Computation for QMS Classification

This module computes:
- The interaction algebra A_int = Alg*(H, L_1, ..., L_m)
- The center Z(A_int)
- Minimal central projections
- The central deficiency δ_cen

Author: Paolo Vella
"""

import numpy as np
from scipy import linalg
from typing import List, Tuple, Optional
from dataclasses import dataclass


def dagger(A: np.ndarray) -> np.ndarray:
    """Conjugate transpose (dagger operation)."""
    return A.conj().T


def commutator(A: np.ndarray, B: np.ndarray) -> np.ndarray:
    """Compute [A, B] = AB - BA."""
    return A @ B - B @ A


def is_hermitian(A: np.ndarray, tol: float = 1e-10) -> bool:
    """Check if matrix is Hermitian."""
    return np.allclose(A, dagger(A), atol=tol)


def gram_schmidt_matrices(matrices: List[np.ndarray], tol: float = 1e-10) -> List[np.ndarray]:
    """
    Gram-Schmidt orthonormalization for matrices using Frobenius inner product.
    Returns orthonormal basis for span of input matrices.
    """
    result = []
    for M in matrices:
        # Subtract projections onto existing basis
        v = M.copy().astype(complex)
        for basis_elem in result:
            # Frobenius inner product: Tr(A† B)
            coeff = np.trace(dagger(basis_elem) @ v)
            v = v - coeff * basis_elem

        # Check if linearly independent
        norm = np.sqrt(np.abs(np.trace(dagger(v) @ v)))
        if norm > tol:
            result.append(v / norm)

    return result


def closure_under_multiplication(basis: List[np.ndarray], tol: float = 1e-10) -> List[np.ndarray]:
    """
    Extend a vector space basis to be closed under multiplication.
    Returns basis for the algebra generated by the input.
    """
    current_basis = list(basis)
    changed = True

    while changed:
        changed = False
        new_elements = []

        for A in current_basis:
            for B in current_basis:
                # Compute product
                AB = A @ B

                # Check if AB is in span of current basis
                coeffs = np.zeros(len(current_basis), dtype=complex)
                residual = AB.copy()

                for i, basis_elem in enumerate(current_basis):
                    coeff = np.trace(dagger(basis_elem) @ residual)
                    coeffs[i] = coeff
                    residual = residual - coeff * basis_elem

                # Add Gram-Schmidt orthogonalized elements
                for elem in new_elements:
                    coeff = np.trace(dagger(elem) @ residual)
                    residual = residual - coeff * elem

                norm = np.sqrt(np.abs(np.trace(dagger(residual) @ residual)))
                if norm > tol:
                    new_elements.append(residual / norm)
                    changed = True

        current_basis.extend(new_elements)

    return current_basis


def closure_under_dagger(basis: List[np.ndarray], tol: float = 1e-10) -> List[np.ndarray]:
    """
    Extend basis to be closed under conjugate transpose.
    """
    current_basis = gram_schmidt_matrices(basis, tol)

    for M in list(current_basis):
        Mdag = dagger(M)
        # Check if M† is in span
        residual = Mdag.copy()
        for basis_elem in current_basis:
            coeff = np.trace(dagger(basis_elem) @ residual)
            residual = residual - coeff * basis_elem

        norm = np.sqrt(np.abs(np.trace(dagger(residual) @ residual)))
        if norm > tol:
            current_basis.append(residual / norm)

    return gram_schmidt_matrices(current_basis, tol)


def compute_interaction_algebra(H: np.ndarray,
                                jump_ops: List[np.ndarray],
                                tol: float = 1e-10) -> List[np.ndarray]:
    """
    Compute the interaction algebra A_int = Alg*(H, L_1, ..., L_m).

    Parameters:
        H: Hamiltonian (Hermitian matrix)
        jump_ops: List of jump operators L_k
        tol: Numerical tolerance

    Returns:
        Orthonormal basis for A_int (w.r.t. Frobenius inner product)
    """
    n = H.shape[0]

    # Start with generators: {I, H} ∪ {L_k} ∪ {L_k†}
    generators = [np.eye(n, dtype=complex), H.astype(complex)]
    for L in jump_ops:
        generators.append(L.astype(complex))
        generators.append(dagger(L))

    # Orthonormalize
    basis = gram_schmidt_matrices(generators, tol)

    # Close under multiplication (this automatically closes under addition and scalars)
    basis = closure_under_multiplication(basis, tol)

    # Ensure closed under dagger (should already be, but verify)
    basis = closure_under_dagger(basis, tol)

    # Final closure under multiplication
    basis = closure_under_multiplication(basis, tol)

    return basis


def compute_center(algebra_basis: List[np.ndarray], tol: float = 1e-10) -> List[np.ndarray]:
    """
    Compute the center Z(A) = {X ∈ A : [X, Y] = 0 for all Y ∈ A}.

    Parameters:
        algebra_basis: Orthonormal basis for algebra A
        tol: Numerical tolerance

    Returns:
        Orthonormal basis for the center Z(A)
    """
    dim = len(algebra_basis)
    if dim == 0:
        return []

    n = algebra_basis[0].shape[0]

    # Build the commutator constraint matrix
    # For X = Σ_i x_i B_i to commute with all B_j:
    # [X, B_j] = Σ_i x_i [B_i, B_j] = 0
    # This gives linear constraints on the coefficients x_i
    #
    # Build matrix M of size (dim * n²) × dim where:
    # Column i contains vec([B_i, B_1]), vec([B_i, B_2]), ..., vec([B_i, B_dim]) stacked
    # The null space of M gives coefficients for center elements.

    M = np.zeros((dim * n * n, dim), dtype=complex)

    for i, B_i in enumerate(algebra_basis):
        for j, B_j in enumerate(algebra_basis):
            comm = commutator(B_i, B_j)
            # Place vec([B_i, B_j]) in column i, rows j*n² to (j+1)*n²
            M[j * n * n : (j + 1) * n * n, i] = comm.flatten()

    # Find null space of M using SVD
    U, S, Vh = linalg.svd(M, full_matrices=True)

    # Null space vectors are rows of Vh corresponding to zero singular values
    null_mask = S < tol
    # Handle case where some singular values are exactly zero
    rank = np.sum(~null_mask)
    null_dim = dim - rank

    if null_dim == 0:
        # Only scalar multiples of identity (which may or may not be in basis)
        # Check if identity is in the algebra
        identity = np.eye(n, dtype=complex)
        for B in algebra_basis:
            if np.allclose(B / np.linalg.norm(B, 'fro'), identity / np.linalg.norm(identity, 'fro'), atol=tol):
                return [identity / np.linalg.norm(identity, 'fro')]
        return []

    # Null space is spanned by last null_dim rows of Vh
    null_vectors = Vh[rank:, :]

    # Convert null vectors back to matrices
    center_basis = []
    for k in range(null_vectors.shape[0]):
        coeffs = null_vectors[k, :]
        # Reconstruct matrix: X = Σ_i coeffs[i] * B_i
        X = sum(coeffs[i] * algebra_basis[i] for i in range(dim))
        center_basis.append(X)

    # Orthonormalize
    return gram_schmidt_matrices(center_basis, tol)


def central_deficiency(H: np.ndarray,
                       jump_ops: List[np.ndarray],
                       tol: float = 1e-10) -> int:
    """
    Compute the central deficiency δ_cen = dim Z(A_int) - 1.

    Parameters:
        H: Hamiltonian
        jump_ops: List of jump operators
        tol: Numerical tolerance

    Returns:
        Central deficiency δ_cen
    """
    A_int = compute_interaction_algebra(H, jump_ops, tol)
    center = compute_center(A_int, tol)
    return len(center) - 1


@dataclass
class InteractionAlgebraInfo:
    """Complete information about the interaction algebra."""
    dim_algebra: int
    dim_center: int
    central_deficiency: int
    algebra_basis: List[np.ndarray]
    center_basis: List[np.ndarray]


def analyze_interaction_algebra(H: np.ndarray,
                                 jump_ops: List[np.ndarray],
                                 tol: float = 1e-10) -> InteractionAlgebraInfo:
    """
    Complete analysis of the interaction algebra.

    Returns:
        InteractionAlgebraInfo with all computed data
    """
    A_int = compute_interaction_algebra(H, jump_ops, tol)
    center = compute_center(A_int, tol)

    return InteractionAlgebraInfo(
        dim_algebra=len(A_int),
        dim_center=len(center),
        central_deficiency=len(center) - 1,
        algebra_basis=A_int,
        center_basis=center
    )


# ============================================================================
# Test Cases
# ============================================================================

def test_two_level_amplitude_damping():
    """
    Test: 2-level amplitude damping
    H = ω |1⟩⟨1|
    L = √γ |0⟩⟨1|

    Expected: A_int = M_2(ℂ), so Z(A_int) = ℂ·I, δ_cen = 0
    """
    omega, gamma = 1.0, 0.5

    # Basis states
    e0 = np.array([[1], [0]], dtype=complex)
    e1 = np.array([[0], [1]], dtype=complex)

    # Hamiltonian
    H = omega * (e1 @ e1.T.conj())

    # Jump operator
    L = np.sqrt(gamma) * (e0 @ e1.T.conj())

    info = analyze_interaction_algebra(H, [L])

    print("2-Level Amplitude Damping:")
    print(f"  dim(A_int) = {info.dim_algebra}")
    print(f"  dim(Z(A_int)) = {info.dim_center}")
    print(f"  δ_cen = {info.central_deficiency}")
    print(f"  Expected: δ_cen = 0")
    print()

    return info


def test_pure_dephasing():
    """
    Test: n-level pure dephasing
    H = Σ_k ω_k |k⟩⟨k| (diagonal)
    L = Σ_k √γ_k |k⟩⟨k| (diagonal)

    Expected: A_int = diagonal matrices, Z(A_int) = A_int, δ_cen = n-1
    """
    n = 3
    omega = np.array([1.0, 2.0, 3.0])
    gamma = np.array([0.5, 0.7, 0.3])

    # Diagonal Hamiltonian
    H = np.diag(omega.astype(complex))

    # Diagonal jump operator
    L = np.diag(np.sqrt(gamma).astype(complex))

    info = analyze_interaction_algebra(H, [L])

    print(f"{n}-Level Pure Dephasing:")
    print(f"  dim(A_int) = {info.dim_algebra}")
    print(f"  dim(Z(A_int)) = {info.dim_center}")
    print(f"  δ_cen = {info.central_deficiency}")
    print(f"  Expected: δ_cen = {n-1}")
    print()

    return info


def test_two_blocks():
    """
    Test: System with two decoupled blocks
    Block 1: 2×2 full algebra
    Block 2: 2×2 full algebra

    Expected: A_int = M_2 ⊕ M_2, Z(A_int) = ℂ ⊕ ℂ, δ_cen = 1
    """
    # 4×4 block diagonal structure
    H = np.zeros((4, 4), dtype=complex)
    H[0:2, 0:2] = np.array([[1, 0.5], [0.5, 2]])  # Block 1 Hamiltonian
    H[2:4, 2:4] = np.array([[3, 0.3], [0.3, 4]])  # Block 2 Hamiltonian

    # Jump operator in block 1 only
    L1 = np.zeros((4, 4), dtype=complex)
    L1[0, 1] = 1.0  # |0⟩⟨1| in block 1

    # Jump operator in block 2 only
    L2 = np.zeros((4, 4), dtype=complex)
    L2[2, 3] = 1.0  # |2⟩⟨3| in block 2

    info = analyze_interaction_algebra(H, [L1, L2])

    print("Two Decoupled 2×2 Blocks:")
    print(f"  dim(A_int) = {info.dim_algebra}")
    print(f"  dim(Z(A_int)) = {info.dim_center}")
    print(f"  δ_cen = {info.central_deficiency}")
    print(f"  Expected: δ_cen = 1 (two blocks)")
    print()

    return info


if __name__ == "__main__":
    print("=" * 60)
    print("Interaction Algebra Tests")
    print("=" * 60)
    print()

    test_two_level_amplitude_damping()
    test_pure_dephasing()
    test_two_blocks()
